{
	// Place your snippets for powershell here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"PsNx Pode Web Table": {
		"prefix": "PsNxSystemWebTable",
		"body": [
			"Add-PodeWebPage -Name '$1' -Icon '$2' -Group '$3' -ScriptBlock {",
			"\tNew-PodeWebCard -Content  @(",
			"\t\tNew-PodeWebTable -Name '$1' -ScriptBlock {",
			"\t\t\t[array]$4 = ($5)",
			"\t\t\tforeach(\\$line in $4) {",
			"\t\t\t\t[ordered]@{",
			"\t\t\t\t\t$6 = \\$line",
			"\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t)",
			"}",
		]
	},
	"PsNx Pode Text Plain Endpoint": {
		"prefix": "PsNxPodeText",
		"body": [
			"Add-PodeRoute -Method Get -Path '/llm/$0' -ScriptBlock {",
			"    $1 = (Invoke-Expression '$2') | Out-String",
			"    Write-PodeTextResponse -ContentType 'text/plain' -Value $1",
			"}"
		]
	},
	"PsNx System Json Endpoint": {
		"prefix": "PsNxPodeJson",
		"body": [
			"Add-PodeRoute -Method Get -Path '/system/$1' -ScriptBlock {",
			"\ttry{",
			"\t\\$jasonAsString = $2 | Out-String",
			"\tWrite-PodeJsonResponse -ContentType 'application/json' -Value $2",
			"\t}",
			"\tcatch {",
			"\t\tWrite-Host \\$_",
			"\t}",
			"}"
		]
	},
	"PsNx Function": {
		"prefix": "PsNxFunction",
		"body": [
			"function ${0:FunctionName} {",
			"\t[CmdletBinding()]",
			"\tparam(${1:type}${2:Variable})",
			"\ttry {",
			"\t\t$2 # Code goes here",
			"\t}catch{",
			"\t\tWrite-Error \\$_",
			"\t\treturn @{ ",
			"\t\t\tError = \\$_",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"PsNx Assert Mock": {
		"prefix": "PsNxAssertMock",
		"body": [
			"$$assertMockParams = @{",
			"\t'CommandName' = '${1:Command}'",
			"\t'Times'       = ${2:1}",
			"\t'Exactly'     = $$true",
			"}",
			"Assert-MockCalled @assertMockParams"
		],
		"description": "AssertMock snippet for Pestering"
	},
	"Example-Splatting": {
		"prefix": "PsNxSplat",
		"description": "Example: PowerShell splatting technique snippet",
		"body": [
			"\\$Params = @{",
			"\tModule = '*'",
			"\tVerb = 'Get'",
			"}",
			"Get-Command @Params"
		]
	},
	"Example-Switch": {
		"prefix": "PsNxSwitch",
		"description": "Example: switch statement snippet",
		"body": [
			"switch (${variable:\\$x})",
			"{",
			"\t'${val:value1}' { $1 }",
			"\t{\\$_ -in 'A','B','C'} {}",
			"\t'value3' {}",
			"\tDefault {}",
			"}"
		]
	},
	"Throw Terminating Error": {
		"prefix": "PsNxTerminateError",
		"body": [
			"\\$Exception     = New-Object ${1:System.ArgumentException} (\"${2:Invalid argument provided.}\")\r",
			"\\$ErrorCategory = [System.Management.Automation.ErrorCategory]::${3:InvalidArgument}\r",
			"# Exception, ErrorId as [string], Category, and TargetObject (e.g. the parameter that was invalid)\r",
			"\\$ErrorRecord   = New-Object System.Management.Automation.ErrorRecord(\\$Exception, '${4:InvalidArgument}', \\$ErrorCategory, ${5:\\$null})\r",
			"\\$PSCmdlet.ThrowTerminatingError(\\$ErrorRecord)"
		],
		"description": "Throw a full terminating error."
	},
	"PesterContext": {
		"prefix": "PsNxContextPester",
		"description": "Pester - Context block",
		"body": [
			"Context \"${1:ContextName}\" {",
			"\t${0:$TM_SELECTED_TEXT}",
			"}"
		]
	},
	"PesterContextIt": {
		"prefix": "PsNxItContextPester",
		"description": "Pester - Context block with nested It block",
		"body": [
			"Context \"${1:ContextName}\" {",
			"\tIt \"${2:ItName}\" {",
			"\t\t${3:${TM_SELECTED_TEXT:Assertion}}",
			"\t}$0",
			"}"
		]
	},
	"PesterDescribeBlock": {
		"prefix": "PsNxDescribePester",
		"description": "Pester Describe block",
		"body": [
			"Describe \"${1:DescribeName}\" {",
			"\t${0:TM_SELECTED_TEXT}",
			"}"
		]
	},
	"PesterDescribeContextIt": {
		"prefix": "PsNxDescribeItPester",
		"description": "Pester Describe block with nested Context & It blocks",
		"body": [
			"Describe \"${1:DescribeName}\" {",
			"\tContext \"${2:ContextName}\" {",
			"\t\tIt \"${3:ItName}\" {",
			"\t\t\t${4:${TM_SELECTED_TEXT:Assertion}}",
			"\t\t}$0",
			"\t}",
			"}"
		]
	},
	"PesterIt": {
		"prefix": "PsNxItPester",
		"description": "Pester - It block",
		"body": [
			"It \"${1:ItName}\" {",
			"\t${2:${TM_SELECTED_TEXT:Assertion}}",
			"}$0"
		]
	},
	"Pester for Parameter": {
		"prefix": "PsNxParamPester",
		"body": [
			"It \"${1:FunctionName} Should have a parameter ${2:ParameterName}\" {",
			"\t(Get-Command ${1:FunctionName}).Parameters['${2:ParameterName}'].Count | Should -Be 1",
			"}"
		],
		"description": "Pester Test for Parameter"
	},
	"Pester for Mandatory Parameter": {
		"prefix": "PsNxMandatoryPester",
		"body": [
			"It \"${1:FunctionName} Should have a mandatory parameter ${2:ParameterName}\" {",
			"\t(Get-Command ${1:FunctionName}).Parameters['${2:ParameterName}'].Attributes.Mandatory | Should -BeTrue",
			"}"
		],
		"description": "Pester Test for Parameter"
	},
	"PsNx LogPipe Getter Function": {
		"prefix": "PsNxGetterLogPipe",
		"body": [
			"#----------------------------------------------------------------------",
			"# Function: Get-${1:ResourceName}",
			"#----------------------------------------------------------------------",
			"<#",
			".SYNOPSIS",
			"Gets ${2:description of what it gets}, optionally including error details.",
			".DESCRIPTION",
			"Retrieves ${3:detailed description}. Outputs PSCustomObjects.",
			"Uses -ErrorAction SilentlyContinue and -ErrorVariable to capture non-terminating errors.",
			"If -ShowErrors is specified, PSCustomObjects representing non-terminating errors are output.",
			"Terminating errors also result in an Error-type PSCustomObject.",
			"All output objects have a 'Type' property ('${4:SuccessType}' or 'Error').",
			".PARAMETER ShowErrors",
			"If specified, detailed PSCustomObjects for non-terminating errors will be included.",
			".OUTPUTS",
			"[PSCustomObject] with properties based on 'Type':",
			"    - Type: '${4:SuccessType}' | 'Error'",
			"    - If Type='${4:SuccessType}': ${5:Property1}, ${6:Property2}, ...",
			"    - If Type='Error': (Properties from New-LogErrorObject)",
			".EXAMPLE",
			"Get-${1:ResourceName} | Where-Object { \\$_.Type -eq '${4:SuccessType}' }",
			"# Gets only the successful objects, silently ignores errors.",
			".EXAMPLE",
			"Get-${1:ResourceName} -ShowErrors",
			"# Outputs a stream containing BOTH success objects and error objects.",
			"#> ",
			"function Get-${1:ResourceName} {",
			"    [CmdletBinding()]",
			"    param(",
			"        [Parameter(Mandatory = \\$false)]",
			"        [switch]\\$ShowErrors",
			"        ${7:# Add other parameters here}",
			"    )",
			"",
			"    \\$CollectedErrors = @()",
			"    \\$OutputObjects = [System.Collections.Generic.List[object]]::new()",
			"",
			"    try {",
			"        # --- Core Logic (e.g., Get-ChildItem, Get-Service) ---",
			"        ${8:Get-Something} -Parameter value `",
			"            -ErrorAction SilentlyContinue `",
			"            -ErrorVariable +CollectedErrors | ForEach-Object {",
			"                # Add successful results, Type property last",
			"                \\$OutputObjects.Add([PSCustomObject]@{",
			"                        ${5:Property1} = \\$_.${9:SourceProperty1}",
			"                        ${6:Property2} = \\$_.${10:SourceProperty2}",
			"                        # Add more properties as needed",
			"                        Type     = '${4:SuccessType}'",
			"                    })",
			"            }",
			"    }",
			"    catch {",
			"        # Handle TERMINATING errors",
			"        \\$errorDetail = New-LogErrorObject -ErrorRecord \\$_ -IsTerminatingError \\$true",
			"        \\$OutputObjects.Add(\\$errorDetail)",
			"    }",
			"",
			"    # Process and add NON-TERMINATING errors if requested",
			"    if (\\$ShowErrors.IsPresent -and \\$CollectedErrors.Count -gt 0) {",
			"        foreach (\\$err in \\$CollectedErrors) {",
			"            \\$errorDetail = New-LogErrorObject -ErrorRecord \\$err -IsTerminatingError \\$false",
			"            \\$OutputObjects.Add(\\$errorDetail)",
			"        }",
			"    }",
			"",
			"    # Output ALL collected objects",
			"    \\$OutputObjects",
			"}",
			""
		],
		"description": "Scaffolding for a LogPipe-style 'Getter' function (e.g., Get-VarLogs)"
	},
	"PsNx LogPipe Reader Function": {
		"prefix": "PsNxReaderLogPipe",
		"body": [
			"#----------------------------------------------------------------------",
			"# Function: Read-${1:LogType}",
			"#----------------------------------------------------------------------",
			"<#",
			".SYNOPSIS",
			"Reads and formats the ${2:log type} log file, optionally including error/status details.",
			".DESCRIPTION",
			"Reads the specified ${2:log type} log file line by line, parsing entries into structured objects.",
			"Handles file access and parsing errors. Outputs detailed error objects if requested or",
			"if terminating errors occur. If the file is processed successfully but is empty, outputs",
			"a Status object.",
			".PARAMETER Path",
			"The full path to the log file. Defaults to '${3:/path/to/default.log}'.",
			".PARAMETER ShowErrors",
			"If specified, detailed PSCustomObjects for non-terminating parsing errors will be included.",
			".OUTPUTS",
			"[PSCustomObject] with properties based on 'Type':",
			"    - Type: '${4:LogEntryType}' | 'Error' | 'Status'",
			"    - If Type='${4:LogEntryType}': ${5:Property1}, ${6:Property2}, ...",
			"    - If Type='Error': (Properties from New-LogErrorObject)",
			"    - If Type='Status': Message, Path",
			".EXAMPLE",
			"Read-${1:LogType} -ShowErrors",
			"# Outputs a stream containing LogEntry objects and Error objects.",
			"#> ",
			"function Read-${1:LogType} {",
			"    [CmdletBinding()]",
			"    param(",
			"        [Parameter(Mandatory = \\$false)]",
			"        [string]\\$Path = '${3:/path/to/default.log}',",
			"",
			"        [Parameter(Mandatory = \\$false)]",
			"        [switch]\\$ShowErrors",
			"        ${7:# Add other parameters like -Tail here}",
			"    )",
			"",
			"    \\$OutputObjects = [System.Collections.Generic.List[object]]::new()",
			"    \\$terminatingReadErrorOccurred = \\$false",
			"    # Define your regex pattern here",
			"    \\$pattern = '${8:^(\\S+)\\s+(.*)}' # Example pattern",
			"",
			"    # --- File Existence Check ---",
			"    \\$fileInfo = Get-Item -LiteralPath \\$Path -ErrorAction SilentlyContinue",
			"    if (-not \\$fileInfo) {",
			"        \\$exception = [System.IO.FileNotFoundException]::new(\"Log file not found at path: \\$Path\", \\$Path)",
			"        \\$errorRecord = [System.Management.Automation.ErrorRecord]::new(\\$exception, 'FileNotFound', [System.Management.Automation.ErrorCategory]::ObjectNotFound, \\$Path)",
			"        \\$errorDetail = New-LogErrorObject -ErrorRecord \\$errorRecord -IsTerminatingError \\$true",
			"        \\$errorDetail; return",
			"    }",
			"",
			"    # --- Read and Parse File ---",
			"    try {",
			"        if (\\$fileInfo.Length -eq 0) {",
			"            Write-Verbose \"File '\\$Path' exists but is empty.\"",
			"        }",
			"        else {",
			"            \\$getContentParams = @{ Path = \\$Path }",
			"            # if (\\$Tail -gt 0) { \\$getContentParams.Add('Tail', \\$Tail) } # Example for -Tail",
			"",
			"            Get-Content @getContentParams | ForEach-Object {",
			"                \\$line = \\$_",
			"                if (\\$line -match \\$pattern) {",
			"                    try {",
			"                        # --- Successful Parse ---",
			"                        \\$OutputObjects.Add([PSCustomObject]@{",
			"                                ${5:Property1} = \\$matches[1]",
			"                                ${6:Property2} = \\$matches[2]",
			"                                # Add more properties based on regex captures",
			"                                # Attempt timestamp parsing if applicable:",
			"                                # Timestamp = try { [datetime]\\$matches[1] } catch { \\$null }",
			"                                Type      = '${4:LogEntryType}'",
			"                            })",
			"                    }",
			"                    catch {",
			"                        # --- Line Parsing Error ---",
			"                        if (\\$ShowErrors.IsPresent) {",
			"                            \\$parseException = [System.FormatException]::new(\"Failed to process line: \\$line\", \\$_.Exception)",
			"                            \\$parseErrorRecord = [System.Management.Automation.ErrorRecord]::new(\\$parseException, 'LineProcessingError', [System.Management.Automation.ErrorCategory]::ParserError, \\$line)",
			"                            \\$errorDetail = New-LogErrorObject -ErrorRecord \\$parseErrorRecord -IsTerminatingError \\$false",
			"                            \\$OutputObjects.Add(\\$errorDetail)",
			"                        }",
			"                    }",
			"                }",
			"                else {",
			"                    # --- Line Format Mismatch ---",
			"                    if (\\$ShowErrors.IsPresent -and -not([string]::IsNullOrWhiteSpace(\\$line))) {",
			"                        \\$matchException = [System.FormatException]::new('Line did not match expected format.')",
			"                        \\$matchErrorRecord = [System.Management.Automation.ErrorRecord]::new(\\$matchException, 'FormatMismatch', [System.Management.Automation.ErrorCategory]::ParserError, \\$line)",
			"                        \\$errorDetail = New-LogErrorObject -ErrorRecord \\$matchErrorRecord -IsTerminatingError \\$false",
			"                        \\$OutputObjects.Add(\\$errorDetail)",
			"                    }",
			"                }",
			"            } # End ForEach-Object",
			"        }",
			"    }",
			"    catch {",
			"        # --- Handle GET-CONTENT errors ---",
			"        \\$terminatingReadErrorOccurred = \\$true",
			"        \\$errorDetail = New-LogErrorObject -ErrorRecord \\$_ -IsTerminatingError \\$true",
			"        \\$OutputObjects.Add(\\$errorDetail)",
			"    }",
			"",
			"    # --- Final Check for Status Object ---",
			"    if (\\$OutputObjects.Count -eq 0 -and -not \\$terminatingReadErrorOccurred) {",
			"        if ((Get-Item -LiteralPath \\$Path -ErrorAction SilentlyContinue).Length -eq 0) {",
			"            \\$OutputObjects.Add([PSCustomObject]@{",
			"                    Message = 'File processed successfully but was empty.'",
			"                    Path    = \\$Path",
			"                    Type    = 'Status'",
			"                })",
			"        }",
			"        else {",
			"             \\$OutputObjects.Add([PSCustomObject]@{",
			"                    Message = \"Log file processed, but no lines matched the expected format or parsed successfully (run with -ShowErrors for details).\"",
			"                    Path    = \\$Path",
			"                    Type    = 'Status'",
			"                })",
			"        }",
			"    }",
			"",
			"    # Output ALL collected objects",
			"    \\$OutputObjects",
			"}",
			""
		],
		"description": "Scaffolding for a LogPipe-style 'Reader' function (e.g., Read-Log, Read-LogAlternatives)"
	},
	"PsNx LogPipe Pipeline Processor Function": {
		"prefix": "PsNxProcessorLogPipe",
		"body": [
			"#----------------------------------------------------------------------",
			"# Function: ${1:Verb}-${2:Noun}",
			"#----------------------------------------------------------------------",
			"<#",
			".SYNOPSIS",
			"${3:Brief description of what the function does to pipeline objects}.",
			".DESCRIPTION",
			"This pipeline function processes objects, typically from a Read-Log* function.",
			"It checks for Type='${4:InputLogEntryType}' and performs ${5:action} based on ${6:criteria}.",
			"Matching '${4:InputLogEntryType}' objects are ${7:passed through/transformed}.",
			"Other object types (like 'Error' or 'Status') are passed through unfiltered.",
			"${8:# Add details about end block behavior if applicable, e.g., outputting a summary}",
			".PARAMETER InputObject",
			"[PSCustomObject] An object from the pipeline.",
			"${9:# Add other parameters here, e.g., -Keywords, -StartDate}",
			".INPUTS",
			"[PSCustomObject] Objects from a preceding pipeline stage.",
			".OUTPUTS",
			"[PSCustomObject] ${10:Description of output objects, including different Types like Summary, Error, Status, passed-through objects}.",
			".EXAMPLE",
			"Read-Log -LogFile syslog | ${1:Verb}-${2:Noun} ${11:# Add example parameters}",
			"# Example usage description.",
			".NOTES",
			"${12:# Add any relevant notes, e.g., required input properties, case sensitivity}.",
			"#> ",
			"function ${1:Verb}-${2:Noun} {",
			"    [CmdletBinding()]",
			"    param (",
			"        [Parameter(Mandatory = \\$true, ValueFromPipeline = \\$true)]",
			"        [PSCustomObject]\\$InputObject",
			"        ${13:# Add other parameters here}",
			"    )",
			"",
			"    begin {",
			"        # Initialize state variables if needed (e.g., counters, lists, stopwatch)",
			"        Write-Verbose 'Initializing ${1:Verb}-${2:Noun} pipeline processing.'",
			"        ${14:\\$processedItems = [System.Collections.Generic.List[object]]::new()}",
			"    }",
			"",
			"    process {",
			"        # Default to passing the object through",
			"        \\$passThrough = \\$true",
			"        \\$outputCurrentObject = \\$InputObject # Object to potentially output",
			"",
			"        try {",
			"            # Check if it's the type of object we want to process",
			"            if (\\$InputObject.PSObject.Properties['Type'] -and \\$InputObject.Type -eq '${4:InputLogEntryType}') {",
			"                # Check for necessary properties (e.g., Message, Timestamp)",
			"                \\$requiredProp = \\$InputObject.PSObject.Properties['${15:RequiredProperty}']",
			"                if (\\$requiredProp -and \\$requiredProp.Value) { # Add more specific checks if needed",
			"                    # --- Apply Filter/Transformation Logic ---",
			"                    Write-Verbose \"Processing '${4:InputLogEntryType}' object...\"",
			"                    if (${16:# Add condition here, e.g., \\$InputObject.Message -match 'Error'}) {",
			"                        # Condition met, keep \\$passThrough = \\$true",
			"                        # Or transform the object: \\$outputCurrentObject = ...",
			"                    }",
			"                    else {",
			"                        # Condition not met, filter it out",
			"                        \\$passThrough = \\$false",
			"                        Write-Verbose 'Object does not meet criteria. Filtering.'",
			"                    }",
			"                }",
			"                else {",
			"                    Write-Verbose \"'${4:InputLogEntryType}' object lacks required property '${15:RequiredProperty}'. Passing through.\"",
			"                    # Keep \\$passThrough = \\$true",
			"                }",
			"            }",
			"            else {",
			"                # Not the type we process (e.g., Error, Status), pass it through",
			"                Write-Verbose \"Input object Type is not '${4:InputLogEntryType}'. Passing through.\"",
			"                # Keep \\$passThrough = \\$true",
			"            }",
			"        }",
			"        catch {",
			"            # Handle errors during processing of a single item",
			"            Write-Warning \"Error processing pipeline item in ${1:Verb}-${2:Noun}: \\$(\\$_.Exception.Message)\"",
			"            # Optionally create and output an error object, or just let it pass",
			"            \\$errorDetail = New-LogErrorObject -ErrorRecord \\$_ -IsTerminatingError \\$false",
			"            \\$outputCurrentObject = \\$errorDetail # Output the error instead",
			"            \\$passThrough = \\$true # Ensure the error object is passed",
			"        }",
			"",
			"        # Output the object if it wasn't filtered out",
			"        if (\\$passThrough) {",
			"            \\$outputCurrentObject",
			"            # Or add to a list for processing in the 'end' block:",
			"            # \\$processedItems.Add(\\$outputCurrentObject)",
			"        }",
			"    }",
			"",
			"    end {",
			"        Write-Verbose 'Finalizing ${1:Verb}-${2:Noun} pipeline processing.'",
			"        # Perform final actions if needed (e.g., output summaries, process \\$processedItems)",
			"        ${17:# if (\\$processedItems.Count -gt 0) { ... } }",
			"        Write-Verbose '${1:Verb}-${2:Noun} processing complete.'",
			"    }",
			"}",
			""
		],
		"description": "Scaffolding for a LogPipe-style Pipeline Processor function (e.g., Search-*, Group-*, Measure-*)"
	},
	"PsNx LogPipe Wrapper Function": {
		"prefix": "PsNxWrapperLogPipe",
		"body": [
			"#----------------------------------------------------------------------",
			"# Function: Show-${1:SpecificLogView}",
			"#----------------------------------------------------------------------",
			"<#",
			".SYNOPSIS",
			"Provides a simplified view of ${2:specific log data}.",
			".DESCRIPTION",
			"A convenience function that calls ${3:underlying function(s)} with specific parameters",
			"and formats the output, typically using Format-Table.",
			".EXAMPLE",
			"Show-${1:SpecificLogView}",
			"# Shows the ${2:specific log data}.",
			"#> ",
			"function Show-${1:SpecificLogView} {",
			"    [CmdletBinding()]",
			"    param(",
			"        ${4:# Add parameters if needed, e.g., to pass to underlying functions}",
			"    )",
			"",
			"    # Call the underlying function(s) with predefined parameters",
			"    ${5:Read-Log -LogFile xyz -Tail 50 | Group-LogByNegative -Keywords 'abc'} | ${6:Format-Table -AutoSize -Wrap}",
			"    ",
			"}",
			""
		],
		"description": "Scaffolding for a simple LogPipe-style Wrapper/Alias function (e.g., Show-SysLog)"
	}
}